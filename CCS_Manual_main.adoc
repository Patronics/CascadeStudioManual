= CascadeStudio Manual
:toc: 
:sectnums: 

== Introduction

=== Purpose
This document is intended to create a short introduction and manual for the software CascadeStudio, created by Johnathon Selstad (@zalo).

=== What is CascadeStudio?
CascadeStudio is a software package that allows the user to enter a kind of script to create a 3D model. This model can then be exported in several formats,  allowing the user to create nice images (renders) or to send the shape to a 3D printer.

The approach to model a 3D shape with code (or script) has become popular through the availability of a software package called OpenSCAD. OpenSCAD has been used initially to model simple shapes for 3D modelling. It uses a technique called Constructive Solid Geometry (CSG), which indicates that 3D shapes are created by combining simple geometric shapes such as boxes, spheres, cylinders into more complex shapes. The operations used to combine these shapes are called boolean operations.

.Simple car model created in OpenSCAD
[#img-car-opencad]
[caption= Figure 1: ]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/openscad-car.jpg[]

This shape is created by entering the following script:

.Code to create a car in OpenSCAD, using two boxes and 6 cylinders (4 wheels and two axles)
----
cube([60,20,10],center=true);
translate([5,0,10 - 0.001])
    cube([30,20,10],center=true);
translate([-20,-15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([-20,15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([20,-15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([20,15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([-20,0,0])
    rotate([90,0,0])
    cylinder(h=30,r=2,center=true);
translate([20,0,0])
    rotate([90,0,0])
    cylinder(h=30,r=2,center=true);
----

CascadeStudio takes this approach a step further. It still retains the approach that shapes are created with a simple script, but it uses a more advanced 3D kernel that allows BRep (Boundary Representation) modelling. In this type of 3D kernel a solid is represented as a collection of surface elements - described using a mathematical equation - that define the boundary between interior and exterior points.

The advantage of a BRep kernel is that in addition to the simple boolean operations it is possible to define how the surfaces are linked to each other. This allows a more easy creation of angled edges (chamfers) or rounded edges (fillets).

.Example of CascadeStudio shape with fillets
[#img-ccs-fillets]
[caption= Figure 2: ]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/ccs-intro.png[]

=== Where can you find CascadeStudio?

CascadeStudio is offered as an open source software at the following github address:

https://github.com/zalo/CascadeStudio

Github is a website intended to develop code. It allows to download complete repositories, change parts and perform version control on the code. Github is especially suited to allow more developers to work on the same set of code files. This also means that you can download all code required to build the software and even create your own version (called "fork") from it.

Johnathon did not start from scratch but took some components that are available as open source as well. The most important components used to create CascadeStudio are:

* opencascade.js (CAD Kernel)
* Monaco Editor (Text Editing and Intellisense)
* Golden Layout (Windowing System)
* three.js (3D Rendering Engine)
* controlkit.js (Buttons/Sliders),
* opentype.js (Font Parsing)
* rawinflate/rawdeflate (URL Code Serialization)
* potpack (Texture Atlas Packing)

=== OpenCascade 3D kernel
CascadeStudio uses the OpenCascade 3D modelling CAD (computer aided design) kernel. This is the same kernel that is used in the FreeCad application. In many respects therefore the output of CascadeStudio is comparable to FreeCad.

The OpenCascade kernel was developed originally by a set of people that started as part of Matra Datavision. Their first CAD system called Euclid was already developed in 1980. This software has evolved an in the passing years the company changed hands several times, first to Areva, then EADS and since 2014 it is part of Capgemini.

The name Cascade is derived from CAS.CADE (Computer Aided Software for Computer Aided Design and Engineering). In 1999 Matra Datavision published CAS.CADE in open source on the Internet as Open CASCADE later renamed to Open CASCADE Technology.

https://www.opencascade.com/

It is interesting to note that the number of 3D kernels used worlwide is rather limited. The most well-known kernels are:

* ACIS by Spatial
* ShapeManager by Autodesk, which is in fact a fork from ACIS
* CGM (Convergence Geometric Modeller) also by Spatial and used in the famous CATIA software.
* Parasolid by Siemens
* C3D Toolkit by C3D Labs
* Open CASCADE

There are also kernels used for socalled Nurbs modelling, used by software packages such as Rhino and Moi3D (Moment of Inspiration). These kernels also use the BRep approach where the surfaces are described by socalled Non-Uniform Rational B-Splines (NURBS). The advantage of NURBS is that these are capable to describe both complex shapes and simple geometric shapes like lines and arcs.



== Starting the program

=== On-line
It is possible to access a fully working version of CascadeStudio by browsing to the following internet address: https://zalo.github.io/CascadeStudio/

Another alternative is to go to the cadhub website at https://cadhub.xyz/

If you sign up at this website it is possible to create a part in CascadeStudio and share this with other users. The site has a gallery of parts that can be studied to learn from the approaches other users have chosen to model their part. Examples can also be found at https://github.com/zalo/CascadeStudio/discussions/categories/show-and-tell but here it is not always possible to check the source code for each part. 

=== Local installation

==== Using a local web server
As the author has published CascadeStudio as an Open Source project, it is possible to download the complete source code from the github page mentioned above. Using the source code it is possible to install a local version on a webserver. Running the program "is as simple as running a server from the root directory (such as the VS Code Live Server, Python live-server, or Node live-server". 

The approach with the VS Code live server is indeed very simple. Follow these steps: 

. install VS Code from [https://code.visualstudio.com]
. Open VSCode and type ctrl+P, type "ext install ritwickdey.liveserver". Alternatively you can open the extension sidebar which opens the Marketplace. If you enter "live server" a long list of extensions is shown. The server from ritwickdey will occur on top of the list as this is by far the most downloaded version. 
. download the code of CascadeStudio from https://github.com/zalo/CascadeStudio by pressing the green "Code" button. Choose "Download ZIP". After downloading unpack the zip file somewhere in your file system. 
. In VS Code, go to "File" and choose the command "Add folder to workspace". Choose the folder "CascadeStudio-master" that you probably just created by unpacking the git repository. 
. Right-click on the file "index.html" and choose "Open with Live Server". In my case my standard browser opened the page "http://127.0.0.1:5500/index.html" and showed the interface to CascadeStudio. 

The server seems to run really inside VS Code, so if you quit VS Code the local version of CascadeStudio will also be shut down. 

==== Install CascadeStudio as a Progressive Web App
An even simpler approach is to install CascadeStudio as a Progressive Web App (PWA). A PWA is a local - almost native - application that can run even without an internet connection. This is achieved by installing a socalled "service worker" that continues to provide the functionality of a web application by using a local cache. To the user the PWA looks identical to a normal application that is installed on the computer. It can be installed in the applications folder and the icon can be shown on the desktop and task bar (or dock). 

To install CascadeStudio as a Web App perform the following steps: 

. Open the page https://zalo.github.io/cascadestudio/ 
. In the browser address bar, click on the "+" sign 
. In the dialog "Install App?" choose "Install"








== Warnings before using CascadeStudio

=== Apart from this document, there is no manual
Although CascadeStudio shows a lot of promise, it needs to be mentioned that the software is not straightforward to use. The author of the software did not (yet?) publish a user manual. Instead the users can use the IntelliSense feature of the Monaco Editor, where a short explanation is shown when the user hovers the mouse pointer over the function name that was just entered. This requires the user to know at least the names of the available functions. Another approach is to visit the code repository for the application and browse through the main library called "CascadeStudioStandardLibrary.js". To fill this gap, this document was written, using a trial and error approach to determine how the different functions are working. 

=== Finding errors in the code is difficult
Another drawback that users should consider is the difficulty of finding errors in the code. The program supplies error warnings, but these are not very informative and sometimes seem to have no relation at all to the code in the editor. The best advice is to build the object in small steps, verifying after each step if an error was introduced. Note that the code is sensitive to missing brackets, so it is good practice to use proper indentation of the code to alleviate finding missing brackets.  

=== The program sometimes acts unpredictable
And finally there are situations where even returning to the previous, working code does not prevent the code from crashing. It might help to disable the caching functionality. If nothing helps, try to save your code to a separate text file and start over in a fresh interface. 



== Commands

=== Sketch
Some of the modelling approaches involve drawing a 2-dimensional sketch first and than creating a wire or solid from this sketch by extruding, revolving or lofting the 2D shapes into a 3-dimensional shape.


==== new Sketch
A new sketch is started with the command

	let mysketch = new Sketch([xvalue,yvalue])

    let face = new Sketch([-10*t,-8*t]).Fillet(2*t).
               LineTo([ 10*t,-8*t]).Fillet(2*t).
               LineTo([  0*t, 8*t]).Fillet(2*t).
               End(true).Face();

This is unique for all functions, as that it needs to be called with the "new" keyword prepended.
The sketch can be expanded by adding lines, arcs, cirles, splines and fillets
	
==== .LineTo

 mysketch.LineTo([xvalue2,yvalue2])
 
==== .Fillet

 mysketch.LineTo([xvalue2,yvalue2]).Fillet(filletradius)
 
==== this.End(closed, reversed)

 mysketch.LineTo([xvalue2,yvalue2]).End(true)

The command .End finishes the sketch. If the boolean is true, the sketch will be closed to the first point of the sketch. This relieves the user from drawing the last line back to the starting point.

==== this.Face(reversed?)
The command .Face() makes a face out of the closed contour.

 mysketch.LineTo([xvalue2,yvalue2]).End(true).Face()

If the boolean is set to true, the face is reversed. In the viewport the face can only be seen from the reverse side.

 let face = new Sketch([-10*t,-8*t]).Fillet(2*t).
               LineTo([ 10*t,-8*t]).Fillet(2*t).
               LineTo([  0*t, 8*t]).Fillet(2*t).
               End(true).Face(true);

==== this.Wire(reversed?)
The command .Wire() creates a wire (a set of connected points in 2D space). Wires can be used to Loft a solid or to extrude a shell.
 
 mysketch.LineTo([xvalue2,yvalue2]).End(true).Wire()
 
Just as with a face, a boolean "true" can be added to Wire to reverse the direction of the wire.


=== this.ArcTo(pointOnArc, arcEnd)
With ArcTo it is possible to define an from the last point to the end point and adding a point on the arc.

----
let face2 = new Sketch([0,0]).
               LineTo([ 5,0]).
               ArcTo([  10,5],[5,10]).Fillet(2).
               LineTo([0,10]).Fillet(2).
               End(true).Fillet(2).Face();
----

.Example of a sketch with ArcTo command
[#img-ccs-arcto]
[caption= Figure 3: ]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/ccs-arcto.png[]

Note that in the example above, only the fillets in the last two lines are visible, as the arc is already chosen tangent to the line.



=== this.BezierTo(bezierControlPoints)
Constructs an order-N Bezier Curve where the first N-1 points are control points and the last point is the endpoint of the curve.

=== this.BSplineTo(bsplinePoints)
Constructs a BSpline from the previous point through this set of points.

=== Polygon(points, wire)
With the Polygon command it is possible to shorten the definition of a sketch. The Polygon is defined by a number of three dimensional point in space, defined as [x,y,z] coordinates.

 Polygon([[-25, -15, 0], [25, -15, 0], [0, 35, 0]], true)

The boolean indicates whether the Polygon describes a Wire (true) or a Face (false).

=== Circle(radius, wire)
The circle command can be used to draw a 2-dimensional circle with a specified radius. The arguments to this function are radius, wire?. The wire? parameter indicates whether the circle should be shown and handled as a face or as a wire.



=== BSpline(inPoints, closed)
The Bspline function draws a spline through the points that are entered as a list. The arguments are a list of points, followed by a boolean the indicates whether the wire should be closed (true) or open (other).As can be seen in the example below, the BSpline can also be used as a rail to construct a pipe by sweeping a face along this rail. The Pipe command will be explained below.

  Pipe(face, BSpline([[0,0,0],[0,0,10],[13,-10,30]], false))






== Three dimensional shapes

=== Box(x, y, z, centered)
Creates a rectangular prism with these X, Y, and Z Dimensions

    Box(20, 20, 20*t),

=== Sphere(radius)
Creates a sphere of specified radius

    Translate([0,0,10*t], Sphere(10*t)),

=== Cylinder(radius, height, centered)
Creates a Cylinder with a radius and height. The arguments are radius, height, centered?. The latter is a boolean indicating whether the shape is centered on the workplane, making half of the height appear above the workplane and half below it, or whether the cylinder starts at the workplane and extends the full height into the normal direction. Omitting the last parameter defaults to "not centered".

    Cylinder(10, 20*t)

=== Cone(radius1, radius2, height)
Creates a revolved trapezoid with differing top and bottom radii. The arguments to this function are radius1, radius2 and height.

    Cone(15, 8*t, 15),

=== Text3D
Creates 3D Text from a TrueType font

    Text3D("Hi!", 36, 0.15*t, "Consolas"),


== Creating shapes from faces or wires
Most of the following functions work both on faces and on wires. Only lofting seems to require wires. A wire can be retrieved from a face using the "GetWire" function:

 GetWire(face)



=== Extrude(face, direction, keepFace)
Extrudes a face along a vector direction

    Extrude(face, [20*(1-t), 0, 20]),

=== RotatedExtrude(wire, height, rotation, keepWire)
Extrudes a wire vertically with a specified height and twist

    RotatedExtrude(GetWire(face), 20*t, 45*t),

=== Pipe(shape, wirePath, keepInputs)
Sweeps a face along a Wire

    Pipe(face, BSpline([[0,0,0],[0,0,10],[13,-10,30]], false)),

=== Revolve
Revolves Edges, Wires, and Faces about the specified Axis

    Rotate([1,0,0], 90, Revolve(Translate([10*t,8*t,0], GetWire(face)), -60, [0, 1, 0])),


=== Loft(wires, keepWires)
Interpolates along an array of wires into a continuous solid shape

    Loft([GetWire(face), Translate([0,0,20], Circle(8, true))]),



== Changing three dimensional shapes

=== Transform(translation, rotation, scale, shapes)


=== Translate(offset, shapes, keepOriginal)


=== Rotate(axis, degrees, shapes, keepOriginal)

=== Scale(scale, shapes, keepOriginal)


=== Offset(shape, offsetDistance, tolerance, keepShape)
Dilates or contracts a shape by the specified distance. This is similar to the socalled minkowski sum with a sphere (known from the OpenSCAD application) which rolls a sphere around the base shape. Note that this can be used to create a rounded cube/box from a normal cube/box.

    Offset(Text3D("H", 36, 0.15, "Roboto"), 2.25*t)
    

=== FilletEdges(shape, radius, edgeList, keepOriginal?)
Round-off an array of edges on a shape (derived from mouse hovering). Note that it is sufficient to list one of the edges in a loop or chain of edges for filleting. The behaviour is not always predictable. It seems that if there are multiple loops of which an edge can be a member, only this single edge is filleted. If there is already another fillet, it seems easier to select just a single edge to fillet a complete loop. Just try an edge and determine the result. Note that you always have to revert back to the original shape if you want to add another edge to the list, as the edge numbering is adapted after the filleting operation. 

    FilletEdges (Cylinder(10, 20), 4*t, [0,2])
    
    
    

=== ChamferEdges(shape, distance, edgeList, keepOriginal?)
Apply a 45-degree cut to an array of edges on a shape
    
    ChamferEdges(Cylinder(10, 20), 4*t, [0,2])
    
=== Difference, Union, Intersection
CSG boolean  a set of shapes from a target shape
    
    Translate([0,0,10], Difference(Sphere(10), [Cylinder(5*t, 30, true)]))


=== Union(objectsToJoin, keepObjects, fuzzValue, keepEdges)


=== Difference(mainBody, objectsToSubtract, keepObjects, fuzzValue, keepEdges)



=== Intersection(objectsToIntersect, keepObjects, fuzzValue, keepEdges)



=== RemoveInternalEdges(shape, keepShape)

// Line up the above shapes into a grid pattern for easy display
let shapeInd = 0;
for(let y = -80; y < 80; y += 40){
    for(let x = -80; x < 80; x += 40){
        if(shapeInd < shapes.length){
            Translate([x, y, 0], shapes[shapeInd]);
        }
        shapeInd++;
    }
}

== Create new functions

 function Sphere(radius) {
   let curSphere = CacheOp(arguments, () => {
    // Construct a Sphere Primitive
     let spherePlane = new oc.gp_Ax2(new oc.gp_Pnt(0, 0, 0), oc.gp.prototype.DZ());
     return new oc.BRepPrimAPI_MakeSphere(spherePlane, radius).Shape();
   });

   sceneShapes.push(curSphere);
   return curSphere;
  }




	
== Interface items

=== Slider(name = "Val", defaultValue = 0.5, min = 0.0, max = 1.0, realTime=false, step, precision)
Creates a simple slider that can be used to adjust parameters of the model

 let t = Slider("Param", 1, 0.4, 1.75);

=== Checkbox(name = "Toggle", defaultValue = false)


 if (Checkbox("Loft?", true)){ Loft([face1, face2, face3], true); }

Button(name = "Action")


=== SaveFile(filename, fileURL)




== Comparison to similar tools

