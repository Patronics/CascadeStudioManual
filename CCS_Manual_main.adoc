= CascadeStudio Manual

== Introduction

=== Purpose
This document is intended to create a short introduction and manual for the software CascadeStudio, created by Johnathon Selstad (@zalo).

=== What is CascadeStudio?
CascadeStudio is a software package that allows the user to enter a kind of script to create a 3D model. This model can then be exported in several formats,  allowing the user to create nice images (renders) or to send the shape to a 3D printer.

The approach to model a 3D shape with code (or script) has become popular through the availability of a software package called OpenSCAD. OpenSCAD has been used initially to model simple shapes for 3D modelling. It uses a technique called Constructive Solid Geometry (CSG), which indicates that 3D shapes are created by combining simple geometric shapes such as boxes, spheres, cylinders into more complex shapes. The operations used to combine these shapes are called boolean operations.

.Simple car model created in OpenSCAD
[#img-car-opencad]
[caption= Figure 1: ]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/openscad-car.jpg[]

This shape is created by entering the following script:

.Code to create a car in OpenSCAD, using two boxes and 6 cylinders (4 wheels and two axles)
----
cube([60,20,10],center=true);
translate([5,0,10 - 0.001])
    cube([30,20,10],center=true);
translate([-20,-15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([-20,15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([20,-15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([20,15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([-20,0,0])
    rotate([90,0,0])
    cylinder(h=30,r=2,center=true);
translate([20,0,0])
    rotate([90,0,0])
    cylinder(h=30,r=2,center=true);
----

CascadeStudio takes this approach a step further. It still retains the approach that shapes are created with a simple script, but it uses a more advanced 3D kernel that allows BRep (Boundary Representation) modelling. In this type of 3D kernel a solid is represented as a collection of surface elements - described using a mathematical equation - that define the boundary between interior and exterior points.

The advantage of a BRep kernel is that in addition to the simple boolean operations it is possible to define how the surfaces are linked to each other. This allows a more easy creation of angled edges (chamfers) or rounded edges (fillets).

.Example of CascadeStudio shape with fillets
[#img-ccs-fillets]
[caption= Figure 2: ]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/ccs-intro.png[]

=== Where can you find CascadeStudio?

CascadeStudio is offered as an open source software at the following github address:

https://github.com/zalo/CascadeStudio

Github is a website intended to develop code. It allows to download complete repositories, change parts and perform version control on the code. Github is especially suited to allow more developers to work on the same set of code files. This also means that you can download all code required to build the software and even create your own version (called "fork") from it.

Johnathon did not start from scratch but took some components that are available as open source as well. The most important components used to create CascadeStudio are:

* opencascade.js (CAD Kernel)
* Monaco Editor (Text Editing and Intellisense)
* Golden Layout (Windowing System)
* three.js (3D Rendering Engine)
* controlkit.js (Buttons/Sliders),
* opentype.js (Font Parsing)
* rawinflate/rawdeflate (URL Code Serialization)
* potpack (Texture Atlas Packing)

=== OpenCascade 3D kernel
CascadeStudio uses the OpenCascade 3D modelling CAD (computer aided design) kernel. This is the same kernel that is used in the FreeCad application. In many respects therefore the output of CascadeStudio is comparable to FreeCad.

The OpenCascade kernel was developed originally by a set of people that started as part of Matra Datavision. Their first CAD system called Euclid was already developed in 1980. This software has evolved an in the passing years the company changed hands several times, first to Areva, then EADS and since 2014 it is part of Capgemini.

The name Cascade is derived from CAS.CADE (Computer Aided Software for Computer Aided Design and Engineering). In 1999 Matra Datavision published CAS.CADE in open source on the Internet as Open CASCADE later renamed to Open CASCADE Technology.

https://www.opencascade.com/

It is interesting to note that the number of 3D kernels used worlwide is rather limited. The most well-known kernels are:

* ACIS by Spatial
* ShapeManager by Autodesk, which is in fact a fork from ACIS
* CGM (Convergence Geometric Modeller) also by Spatial and used in the famous CATIA software.
* Parasolid by Siemens
* C3D Toolkit by C3D Labs
* Open CASCADE

There are also kernels used for socalled Nurbs modelling, used by software packages such as Rhino and Moi3D (Moment of Inspiration). These kernels also use the BRep approach where the surfaces are described by socalled Non-Uniform Rational B-Splines (NURBS). The advantage of NURBS is that these are capable to describe both complex shapes and simple geometric shapes like lines and arcs.


== Starting the program

=== On-line
It is possible to access a fully working version of CascadeStudio by browsing to the following internet address:

    https://zalo.github.io/CascadeStudio/






https://cadhub.xyz/



=== Local installation




== Commands

=== Sketch
Some of the modelling approaches involve drawing a 2-dimensional sketch first and than creating a wire or solid from this sketch by extruding, revolving or lofting the 2D shapes into a 3-dimensional shape.


==== new Sketch
A new sketch is started with the command

	let mysketch = new Sketch([xvalue,yvalue])

    let face = new Sketch([-10*t,-8*t]).Fillet(2*t).
               LineTo([ 10*t,-8*t]).Fillet(2*t).
               LineTo([  0*t, 8*t]).Fillet(2*t).
               End(true).Face();

This is unique for all functions, as that it needs to be called with the "new" keyword prepended.
The sketch can be expanded by adding lines, arcs, cirles, splines and fillets
	
==== .LineTo

 mysketch.LineTo([xvalue2,yvalue2])
 
==== .Fillet

 mysketch.LineTo([xvalue2,yvalue2]).Fillet(filletradius)
 
==== this.End(closed, reversed)

 mysketch.LineTo([xvalue2,yvalue2]).End(true)

The command .End finishes the sketch. If the boolean is true, the sketch will be closed to the first point of the sketch. This relieves the user from drawing the last line back to the starting point.

==== this.Face(reversed?)
The command .Face() makes a face out of the closed contour.

 mysketch.LineTo([xvalue2,yvalue2]).End(true).Face()

If the boolean is set to true, the face is reversed. In the viewport the face can only be seen from the reverse side.

 let face = new Sketch([-10*t,-8*t]).Fillet(2*t).
               LineTo([ 10*t,-8*t]).Fillet(2*t).
               LineTo([  0*t, 8*t]).Fillet(2*t).
               End(true).Face(true);

==== this.Wire(reversed?)
The command .Wire() creates a wire (a set of connected points in 2D space). Wires can be used to Loft a solid or to extrude a shell.
 
 mysketch.LineTo([xvalue2,yvalue2]).End(true).Wire()
 
Just as with a face, a boolean "true" can be added to Wire to reverse the direction of the wire.


=== this.ArcTo(pointOnArc, arcEnd)
With ArcTo it is possible to define an from the last point to the end point and adding a point on the arc.

----
let face2 = new Sketch([0,0]).
               LineTo([ 5,0]).
               ArcTo([  10,5],[5,10]).Fillet(2).
               LineTo([0,10]).Fillet(2).
               End(true).Fillet(2).Face();
----

.Example of a sketch with ArcTo command
[#img-ccs-arcto]
[caption= Figure 3: ]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/ccs-arcto.png[]

Note that in the example above, only the fillets in the last two lines are visible, as the arc is already chosen tangent to the line.



=== this.BezierTo(bezierControlPoints)
Constructs an order-N Bezier Curve where the first N-1 points are control points and the last point is the endpoint of the curve.

=== this.BSplineTo(bsplinePoints)
Constructs a BSpline from the previous point through this set of points.

=== Polygon(points, wire)
With the Polygon command it is possible to shorten the definition of a sketch. The Polygon is defined by a number of three dimensional point in space, defined as [x,y,z] coordinates.

 Polygon([[-25, -15, 0], [25, -15, 0], [0, 35, 0]], true)

The boolean indicates whether the Polygon describes a Wire (true) or a Face (false).

=== Circle(radius, wire)
The circle command can be used to draw a 2-dimensional circle with a specified radius. The arguments to this function are radius, wire?. The wire? parameter indicates whether the circle should be shown and handled as a face or as a wire.



=== BSpline(inPoints, closed)
The Bspline function draws a spline through the points that are entered as a list. The arguments are a list of points, followed by a boolean the indicates whether the wire should be closed (true) or open (other).As can be seen in the example below, the BSpline can also be used as a rail to construct a pipe by sweeping a face along this rail. The Pipe command will be explained below.

  Pipe(face, BSpline([[0,0,0],[0,0,10],[13,-10,30]], false))






== Three dimensional shapes

=== Box(x, y, z, centered)
Creates a rectangular prism with these X, Y, and Z Dimensions

    Box(20, 20, 20*t),

=== Sphere(radius)
Creates a sphere of specified radius

    Translate([0,0,10*t], Sphere(10*t)),

=== Cylinder(radius, height, centered)
Creates a Cylinder with a radius and height. The arguments are radius, height, centered?. The latter is a boolean indicating whether the shape is centered on the workplane, making half of the height appear above the workplane and half below it, or whether the cylinder starts at the workplane and extends the full height into the normal direction. Omitting the last parameter defaults to "not centered".

    Cylinder(10, 20*t)

=== Cone(radius1, radius2, height)
Creates a revolved trapezoid with differing top and bottom radii. The arguments to this function are radius1, radius2 and height.

    Cone(15, 8*t, 15),

=== Text3D
Creates 3D Text from a TrueType font

    Text3D("Hi!", 36, 0.15*t, "Consolas"),


== Creating shapes from faces or wires
Most of the following functions work both on faces and on wires. Only lofting seems to require wires. A wire can be retrieved from a face using the "GetWire" function:

 GetWire(face)



=== Extrude(face, direction, keepFace)
Extrudes a face along a vector direction

    Extrude(face, [20*(1-t), 0, 20]),

=== RotatedExtrude(wire, height, rotation, keepWire)
Extrudes a wire vertically with a specified height and twist

    RotatedExtrude(GetWire(face), 20*t, 45*t),

=== Pipe(shape, wirePath, keepInputs)
Sweeps a face along a Wire

    Pipe(face, BSpline([[0,0,0],[0,0,10],[13,-10,30]], false)),

=== Revolve
Revolves Edges, Wires, and Faces about the specified Axis

    Rotate([1,0,0], 90, Revolve(Translate([10*t,8*t,0], GetWire(face)), -60, [0, 1, 0])),


=== Loft(wires, keepWires)
Interpolates along an array of wires into a continuous solid shape

    Loft([GetWire(face), Translate([0,0,20], Circle(8, true))]),



== Changing three dimensional shapes

=== Transform(translation, rotation, scale, shapes)


=== Translate(offset, shapes, keepOriginal)


=== Rotate(axis, degrees, shapes, keepOriginal)

=== Scale(scale, shapes, keepOriginal)


=== Offset(shape, offsetDistance, tolerance, keepShape)
Dilates or contracts a shape by the specified distance. This is similar to the socalled minkowski sum with a sphere (known from the OpenSCAD application) which rolls a sphere around the base shape. Note that this can be used to create a rounded cube/box from a normal cube/box.

    Offset(Text3D("H", 36, 0.15, "Roboto"), 2.25*t)
    

=== FilletEdges(shape, radius, edgeList, keepOriginal?)
Round-off an array of edges on a shape (derived from mouse hovering)

    FilletEdges (Cylinder(10, 20), 4*t, [0,2])

=== ChamferEdges(shape, distance, edgeList, keepOriginal?)
Apply a 45-degree cut to an array of edges on a shape
    
    ChamferEdges(Cylinder(10, 20), 4*t, [0,2])
    
=== Difference, Union, Intersection
CSG boolean  a set of shapes from a target shape
    
    Translate([0,0,10], Difference(Sphere(10), [Cylinder(5*t, 30, true)]))


=== Union(objectsToJoin, keepObjects, fuzzValue, keepEdges)


=== Difference(mainBody, objectsToSubtract, keepObjects, fuzzValue, keepEdges)



=== Intersection(objectsToIntersect, keepObjects, fuzzValue, keepEdges)



=== RemoveInternalEdges(shape, keepShape)

// Line up the above shapes into a grid pattern for easy display
let shapeInd = 0;
for(let y = -80; y < 80; y += 40){
    for(let x = -80; x < 80; x += 40){
        if(shapeInd < shapes.length){
            Translate([x, y, 0], shapes[shapeInd]);
        }
        shapeInd++;
    }
}

== Create new functions

 function Sphere(radius) {
   let curSphere = CacheOp(arguments, () => {
    // Construct a Sphere Primitive
     let spherePlane = new oc.gp_Ax2(new oc.gp_Pnt(0, 0, 0), oc.gp.prototype.DZ());
     return new oc.BRepPrimAPI_MakeSphere(spherePlane, radius).Shape();
   });

   sceneShapes.push(curSphere);
   return curSphere;
  }




	
== Interface items

=== Slider(name = "Val", defaultValue = 0.5, min = 0.0, max = 1.0, realTime=false, step, precision)
Creates a simple slider that can be used to adjust parameters of the model

 let t = Slider("Param", 1, 0.4, 1.75);

=== Checkbox(name = "Toggle", defaultValue = false)


 if (Checkbox("Loft?", true)){ Loft([face1, face2, face3], true); }

Button(name = "Action")


=== SaveFile(filename, fileURL)




== Comparison to similar tools

