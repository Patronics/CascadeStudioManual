= CascadeStudio Manual
:docdate:
:experimental: 
:toc: 
:sectnums: 

== Introduction

=== Purpose
This document is intended to create a short introduction and manual for the software CascadeStudio, created by Johnathon Selstad (@zalo).

=== What is CascadeStudio?
CascadeStudio is a software package that allows the user to enter a kind of script to create a 3D model. This model can then be exported in several formats,  allowing the user to create nice images (renders) or to send the shape to a 3D printer.

The approach to model a 3D shape with code (or script) has become popular through the availability of a software package called OpenSCAD (Open Scripted-Computer-Aided-Design). OpenSCAD has been used initially to model simple shapes for 3D modelling. It uses a technique called Constructive Solid Geometry (CSG), which indicates that 3D shapes are created by combining simple geometric shapes such as boxes, spheres, cylinders into more complex shapes. The operations used to combine these shapes are called boolean operations.

.Simple car model created in OpenSCAD
[#img-car-opencad]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/openscad-car.jpg[]



This shape is created by entering the following script:

.Code to create a car in OpenSCAD, using two boxes and 6 cylinders (4 wheels and two axles)
----
cube([60,20,10],center=true);
translate([5,0,10 - 0.001])
    cube([30,20,10],center=true);
translate([-20,-15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([-20,15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([20,-15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([20,15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([-20,0,0])
    rotate([90,0,0])
    cylinder(h=30,r=2,center=true);
translate([20,0,0])
    rotate([90,0,0])
    cylinder(h=30,r=2,center=true);
----

CascadeStudio takes this approach a step further. It still retains the approach that shapes are created with a simple script, but it uses a more advanced 3D kernel that allows BRep (Boundary Representation) modelling. In this type of 3D kernel a solid is represented as a collection of surface elements - described using a mathematical equation - that define the boundary between interior and exterior points.

The advantage of a BRep kernel is that in addition to the simple boolean operations it is possible to define how the surfaces are linked to each other. This allows a more easy creation of angled edges (chamfers) or rounded edges (fillets).

.Example of CascadeStudio shape with fillets
[#img-ccs-fillets]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/ccs-car-v2.png[]



=== Where can you find CascadeStudio?

CascadeStudio is offered as an open source software at the following github address:

https://github.com/zalo/CascadeStudio

Github is a website intended to develop code. It allows to download complete repositories, change parts and perform version control on the code. Github is especially suited to allow more developers to work on the same set of code files. This also means that you can download all code required to build the software and even create your own version (called "fork") from it.

Johnathon did not start from scratch but took some components that are available as open source as well. The most important components used to create CascadeStudio are:

* opencascade.js (CAD Kernel)
* Monaco Editor (Text Editing and Intellisense)
* Golden Layout (Windowing System)
* three.js (3D Rendering Engine)
* controlkit.js (Buttons/Sliders),
* opentype.js (Font Parsing)
* rawinflate/rawdeflate (URL Code Serialization)
* potpack (Texture Atlas Packing)

=== OpenCascade 3D kernel
CascadeStudio uses the OpenCascade 3D modelling CAD (computer aided design) kernel. This is the same kernel that is used in the FreeCad application. In many respects therefore the output of CascadeStudio is comparable to FreeCad.

The OpenCascade kernel was developed originally by a set of people that started as part of Matra Datavision. Their first CAD system called Euclid was already developed in 1980. This software has evolved an in the passing years the company changed hands several times, first to Areva, then EADS and since 2014 it is part of Capgemini.

The name Cascade is derived from CAS.CADE (Computer Aided Software for Computer Aided Design and Engineering). In 1999 Matra Datavision published CAS.CADE in open source on the Internet as Open CASCADE later renamed to Open CASCADE Technology.

https://www.opencascade.com/

It is interesting to note that the number of 3D kernels used worlwide is rather limited. The most well-known kernels are:

* ACIS by Spatial
* ShapeManager by Autodesk, which is in fact a fork from ACIS
* CGM (Convergence Geometric Modeller) also by Spatial and used in the famous CATIA software.
* Parasolid by Siemens
* C3D Toolkit by C3D Labs
* Open CASCADE

There are also kernels used for socalled Nurbs modelling, used by software packages such as Rhino and Moi3D (Moment of Inspiration). These kernels also use the BRep approach where the surfaces are described by socalled Non-Uniform Rational B-Splines (NURBS). The advantage of NURBS is that these are capable to describe both complex shapes and simple geometric shapes like lines and arcs.



== Starting the program

=== On-line
It is possible to access a fully working version of CascadeStudio by browsing to the following internet address: https://zalo.github.io/CascadeStudio/

Another alternative is to go to the cadhub website at https://cadhub.xyz/

If you sign up at this website it is possible to create a part in CascadeStudio and share this with other users. The site has a gallery of parts that can be studied to learn from the approaches other users have chosen to model their part. Examples can also be found at https://github.com/zalo/CascadeStudio/discussions/categories/show-and-tell but here it is not always possible to check the source code for each part. 

=== Local installation

==== Using a local web server
As the author has published CascadeStudio as an Open Source project, it is possible to download the complete source code from the github page mentioned above. Using the source code it is possible to install a local version on a webserver. Running the program "is as simple as running a server from the root directory (such as the VS Code Live Server, Python live-server, or Node live-server". 

The approach with the VS Code live server is indeed very simple. Follow these steps: 

. install VS Code from [https://code.visualstudio.com]
. Open VSCode and type kbd:[CMD]+ kbd:[P] to open the command palette and enter "ext install ritwickdey.liveserver". 
+
--
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/vscode_command.png[]
--

. Alternatively you can open the extension sidebar which opens the Marketplace. If you enter "live server" a long list of extensions is shown. The server from ritwickdey will occur on top of the list as this is by far the most downloaded version. 
+
--
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/vscode_extensions.png[]
--
. download the code of CascadeStudio from https://github.com/zalo/CascadeStudio by pressing the green "Code" button. Choose "Download ZIP". After downloading unpack the zip file somewhere in your file system. 
. In VS Code, go to "File" and choose the command "Add folder to workspace". Choose the folder "CascadeStudio-master" that you probably just created by unpacking the git repository. 
. Right-click on the file "index.html" and choose "Open with Live Server". In my case my standard browser opened the page "http://127.0.0.1:5500/index.html" and showed the interface to CascadeStudio.
+
--
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/vscode_start_liveserver.png[]
--

The server seems to run really inside VS Code, so if you quit VS Code the local version of CascadeStudio will also be shut down. 

==== Install CascadeStudio as a Progressive Web App
An even simpler approach is to install CascadeStudio as a Progressive Web App (PWA). A PWA is a local - almost native - application that can run even without an internet connection. This is achieved by installing a socalled "service worker" that continues to provide the functionality of a web application by using a local cache. To the user the PWA looks identical to a normal application that is installed on the computer. It can be installed in the applications folder and the icon can be shown on the desktop and task bar (or dock). 

To install CascadeStudio as a Web App perform the following steps: 

. Open the page https://zalo.github.io/cascadestudio/ 
. In the browser address bar, click on the "+" sign (MS Windows) or on the "download to computer" icon (MacOS). 
+
--
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/install_button.png[]
-- 

. In the dialog "Install App?" choose "Install"
+
--
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/install_app_dialog.png[]
-- 

. When the installation is complete the app can be found in the application folder of your web browser. For example, if you are using Chrome browser, it will be available as a Chrome App. 
+
--
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/chrome_apps.png[]
-- 


''''
== Warnings before using CascadeStudio

=== Apart from this document, there is no manual
Although CascadeStudio shows a lot of promise, it needs to be mentioned that the software is not straightforward to use. The author of the software did not (yet?) publish a user manual. Instead the users can use the IntelliSense feature of the Monaco Editor, where a short explanation is shown when the user hovers the mouse pointer over the function name that was just entered. This requires the user to know at least the names of the available functions. Another approach is to visit the code repository for the application and browse through the main library called "CascadeStudioStandardLibrary.js". To fill this gap, this document was written, using a trial and error approach to determine how the different functions are working. 

=== Finding errors in the code is difficult
Another drawback that users should consider is the difficulty of finding errors in the code. The program supplies error warnings, but these are not very informative and sometimes seem to have no relation at all to the code in the editor. The best advice is to build the object in small steps, verifying after each step if an error was introduced. Note that the code is sensitive to missing brackets, so it is good practice to use proper indentation of the code to alleviate finding missing brackets.  

=== The program sometimes acts unpredictable
And finally there are situations where even returning to the previous, working code does not prevent the code from crashing. It might help to disable the caching functionality. If nothing helps, try to save your code to a separate text file and start over in a fresh interface. 


== First steps

=== The user interface
After starting the program the following interface is presented to the user: 

.Interface of CascadeStudio
[#img-ccs-interface]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/interface.png[]

'''
The interface of CascadeStudio is relatively straightforward. The main window is split into three parts, namely:

* the code editor
* the 3D window
* the processing log 

The users enters the code to generate a 3D shape into the code editor. When the code is complete the program can be triggered by keying kbd:[F5] or clicking on the "Evaluate" button in the 3D window dialog. The processing log shows the result of the processing. If this log end with the message "Generation Complete!" the code most likely did not contain any errors. If there are errors in the code, the processing log will indicate what is wrong. Sometimes the line numbers of the error message make no sense. In that case it can help to analyse what shapes have been succesfully built or which command is mentioned in the error log. This can often indicate the line where the first error occured in the code. 

The shape in the 3D view can be manipulated with the mouse. Pressing the left mouse button (LMB) while dragging rotates the view, pressing the right mouse button (RMB) while dragging pans or shifts the field of view. Rolling the scroll wheel with the mouse pointer inside the 3D view zooms in and out. 

The menu bar contains the following items: 

Cascade Studio 0.0.7:: Opens the github page where the source code of the software can be found
Save project:: Opens a dialog to save the current code. The code is stored inside a json file, which is a plain ascii file. Note that this file contains much more information than only the code shown in the code editor. 
Load project:: Opens a dialog to browse for an earlier stored json file
Save STEP :: saves the current 3D model in the STEP format. STEP stands for "Standard for the Exchange of Product Data" and is a format defined in ISO 10303. It can describe a shape in terms of curves and faces. Additionally it can contain information on material, tolerances and colour of the object.   
SAVE STL:: saves the current 3D model in the STL format. STL or Stereo Lithography format describes the model with a mesh of triangle-shaped polygons. It is therefore an approximation of the 3D shape and may be considered a "lossy" format: data is lost in the conversion towards STL and the original format cannot be recovered from this format. 
SAVE OBJ:: saves the current 3D model in a Wavefront Object format. The OBJ format can contain both information on polygons and curves. It can therefore combine features of both the STEP format and the STL format. However, information on materials and tolerances are not included in the OBJ file. Other 3D programs offer the option to combine a material file with the OBJ file so that an object can be imported into a 3D software package with the correct texture and materials applied to the shape.
Import STEP/IGES/STL:: import a 3D shape in the STEP, IGES and STL format. OpenCascade can only read ASCII-encoded files, not binary encoded files. The imported shapes can be manipulated, but many of the construction commands cannot be applied to these shapes. 
Clear Imported Files:: This menu item clears the imported data from the current JSON file. 


=== The first example program
After starting the program the code editor always contains the code shown below: 

----
let holeRadius = Slider("Radius", 30 , 20 , 40);

let sphere     = Sphere(50);
let cylinderZ  =                     Cylinder(holeRadius, 200, true);
let cylinderY  = Rotate([0,1,0], 90, Cylinder(holeRadius, 200, true));
let cylinderX  = Rotate([1,0,0], 90, Cylinder(holeRadius, 200, true));

Translate([0, 0, 50], Difference(sphere, [cylinderX, cylinderY, cylinderZ]));

Translate([-25, 0, 40], Text3D("Hi!", 36, 0.15, 'Consolas'));
----

.Default code
[#img-ccs-default]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/first-example.png[]

... 
This default code already introduces the user to several concepts of the code which is written in Javascript format: 

Comment lines:: Comment lines start with two forward slashes "//"
Variable declarations:: Variables are declared with the keyword "let". It is not necessary to declare the type of data that is held in the variable. As shown in the example it is possible to declare a variable and assign a value to it in a single line. However, Javascript also allows to do this on two separate lines. Note that a variable name cannot be declared twice. 
Functions:: CascadeStudio offers some functions to decribe or construct 3D shapes. The first six comment lines already mention the most important functions that are offered. As we will see later, it is also possible to define new functions. 

A good starting point can be to apply small changes to the code and to see what happens. The first changes can even be performed using the 3D dialog. The slider labelled "Radius" can be used to adapt the radius of the cylinder that is central to the 3D shape. 

=== Building a simple car
As a next step, let's try to construct a simple version of the car shape shown in the introduction (see <<img-ccs-fillets>>). To create this car in CascadeStudio you have to start the software, delete all the example code on the left side of the interface and enter the code shown below. Then press kbd:[F5] to interpret the code. The result will be shown on the right side in the 3D window. 

----
// Define car design variables
let car_length      = 50;
let car_width       = 20;
let overhang_front  = 8;
let overhang_rear   = 9;
let cabin_width     = 16;
let cabin_length    = 25; // 33 = station, 25=sedan, 15=pickup
let car_height      = 14;
let bonnet_height   = 8;
let bonnet_rounding = 4;
let bonnet_length   = 15;
let wheel_radius    = 5;
let tire_width      = 3;
let tire_protrude   = 1;
let rim_height      = 1;
let tire_compression= 1;
let road_clearance  = 3; 

// Derived properties
let wheel_base      = car_length - overhang_front - overhang_rear;
let cabin_narrowing = (car_width - cabin_width)/2;
let cabin_base      = road_clearance + bonnet_height
let cabin_height    = car_height-bonnet_height

// Draw car body and passenger cabin
let car_body        = Translate([0,0,road_clearance],Box(car_length,car_width,bonnet_height))
let car_cabin       = Translate([bonnet_length,cabin_narrowing,cabin_base-0.5],
                            Box(cabin_length, cabin_width, cabin_height))

// Sculpt the car body more aerodynamically
let car_body_rounded = FilletEdges(car_body,bonnet_rounding,[1,5])
let cabin_aero       = ChamferEdges(car_cabin, cabin_height-0.5 , [1,5])

// Round all edges
let cabin_rounded   = Offset(cabin_aero,1.5);
let car_shrunk = Offset(car_body_rounded,-1);
let car_rounded = Offset(car_shrunk,2); 

// Define wheels and wheel wells (Front/Rear - Left/Right)
let rim              = Rotate([1,0,0],-90, Translate(
                        [overhang_front,
                                   -(wheel_radius-tire_compression),
                                  -(tire_width - tire_protrude)]
                                  , Cylinder(wheel_radius-rim_height,tire_width,true)))
let wheel            = Rotate([1,0,0],-90, Translate( [overhang_front,
                                   -(wheel_radius-tire_compression),
                                  (0.5*tire_protrude)], 
                                  Cylinder(wheel_radius,tire_width,true)));
let wheel_FL         = Difference(wheel,[rim]);
let wheel_well_FL    = Offset(wheel,0.8,0.01,true)
let wheel_RL         = Translate([wheel_base,0,0], wheel_FL, true)
let wheel_well_RL    = Translate([wheel_base,0,0], wheel_well_FL, true)
let wheel_FR         = Rotate([0,0,1],180,Translate([-(2*overhang_front),-car_width ,0], wheel_FL, true))
let wheel_well_FR    = Translate([0,car_width-1,0], wheel_well_FL, true)
let wheel_RR         = Translate([wheel_base,0,0], wheel_FR, true)
let wheel_well_RR    = Translate([wheel_base,0,0], wheel_well_FR, true)

// Subtract the wheel wells from the car-body
Difference(car_rounded,[wheel_well_FL, 
                        wheel_well_RL, 
                        wheel_well_FR, 
                        wheel_well_RR])
----




== Commands

=== Sketch
Some of the modelling approaches involve drawing a 2-dimensional sketch first and than creating a wire or solid from this sketch by extruding, revolving or lofting the 2D shapes into a 3-dimensional shape.

.Using a 2-dimensional sketch as basis to create 3-dimensional shapes
[#img-ccs-sketch]
[caption= Figure 3: ]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/sketch_to_shape.png[1000]


==== new Sketch
A new sketch is started with the command

	let mysketch = new Sketch([xvalue,yvalue])

    let face = new Sketch([-10*t,-8*t]).Fillet(2*t).
               LineTo([ 10*t,-8*t]).Fillet(2*t).
               LineTo([  0*t, 8*t]).Fillet(2*t).
               End(true).Face();

This is unique for all functions, as that it needs to be called with the "new" keyword prepended.
The sketch can be expanded by adding lines, arcs, cirles, splines and fillets
	
==== .LineTo

 mysketch.LineTo([xvalue2,yvalue2])
 
==== .Fillet

 mysketch.LineTo([xvalue2,yvalue2]).Fillet(filletradius)
 
==== this.End(closed, reversed)

 mysketch.LineTo([xvalue2,yvalue2]).End(true)

The command .End finishes the sketch. If the boolean is true, the sketch will be closed to the first point of the sketch. This relieves the user from drawing the last line back to the starting point.

==== this.Face(reversed?)
The command .Face() makes a face out of the closed contour.

 mysketch.LineTo([xvalue2,yvalue2]).End(true).Face()

If the boolean is set to true, the face is reversed. In the viewport the face can only be seen from the reverse side.

 let face = new Sketch([-10*t,-8*t]).Fillet(2*t).
               LineTo([ 10*t,-8*t]).Fillet(2*t).
               LineTo([  0*t, 8*t]).Fillet(2*t).
               End(true).Face(true);

==== this.Wire(reversed?)
The command .Wire() creates a wire (a set of connected points in 2D space). Wires can be used to Loft a solid or to extrude a shell.
 
 mysketch.LineTo([xvalue2,yvalue2]).End(true).Wire()
 
Just as with a face, a boolean "true" can be added to Wire to reverse the direction of the wire.


=== this.ArcTo(pointOnArc, arcEnd)
With ArcTo it is possible to define an from the last point to the end point and adding a point on the arc.

----
let face2 = new Sketch([0,0]).
               LineTo([ 5,0]).
               ArcTo([  10,5],[5,10]).Fillet(2).
               LineTo([0,10]).Fillet(2).
               End(true).Fillet(2).Face();
----

.Example of a sketch with ArcTo command
[#img-ccs-arcto]
[caption= Figure 3: ]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/ccs-arcto.png[]

Note that in the example above, only the fillets in the last two lines are visible, as the arc is already chosen tangent to the line.



=== this.BezierTo(bezierControlPoints)
Constructs an order-N Bezier Curve where the first N-1 points are control points and the last point is the endpoint of the curve.

=== this.BSplineTo(bsplinePoints)
Constructs a BSpline from the previous point through this set of points.

=== Polygon(points, wire)
With the Polygon command it is possible to shorten the definition of a sketch. The Polygon is defined by a number of three dimensional point in space, defined as [x,y,z] coordinates.

 Polygon([[-25, -15, 0], [25, -15, 0], [0, 35, 0]], true)

The boolean indicates whether the Polygon describes a Wire (true) or a Face (false).

=== Circle(radius, wire)
The circle command can be used to draw a 2-dimensional circle with a specified radius. The arguments to this function are radius, wire?. The wire? parameter indicates whether the circle should be shown and handled as a face or as a wire.



=== BSpline(inPoints, closed)
The Bspline function draws a spline through the points that are entered as a list. The arguments are a list of points, followed by a boolean the indicates whether the wire should be closed (true) or open (other).As can be seen in the example below, the BSpline can also be used as a rail to construct a pipe by sweeping a face along this rail. The Pipe command will be explained below.

  Pipe(face, BSpline([[0,0,0],[0,0,10],[13,-10,30]], false))






== Three dimensional shapes

=== Box(x, y, z, centered)
Creates a rectangular prism with these X, Y, and Z Dimensions

    Box(20, 20, 20*t),

=== Sphere(radius)
Creates a sphere of specified radius

    Translate([0,0,10*t], Sphere(10*t)),

=== Cylinder(radius, height, centered)
Creates a Cylinder with a radius and height. The arguments are radius, height, centered?. The latter is a boolean indicating whether the shape is centered on the workplane, making half of the height appear above the workplane and half below it, or whether the cylinder starts at the workplane and extends the full height into the normal direction. Omitting the last parameter defaults to "not centered".

    Cylinder(10, 20*t)

=== Cone(radius1, radius2, height)
Creates a revolved trapezoid with differing top and bottom radii. The arguments to this function are radius1, radius2 and height.

    Cone(15, 8*t, 15),

=== Text3D
Creates 3D Text from a TrueType font

    Text3D("Hi!", 36, 0.15*t, "Consolas"),


== Creating shapes from faces or wires
Most of the following functions work both on faces and on wires. Only lofting seems to require wires. A wire can be retrieved from a face using the "GetWire" function:

 GetWire(face)



=== Extrude(face, direction, keepFace)
Extrudes a face along a vector direction

    Extrude(face, [20*(1-t), 0, 20]),

=== RotatedExtrude(wire, height, rotation, keepWire)
Extrudes a wire vertically with a specified height and twist

    RotatedExtrude(GetWire(face), 20*t, 45*t),

=== Pipe(shape, wirePath, keepInputs)
Sweeps a face along a Wire

    Pipe(face, BSpline([[0,0,0],[0,0,10],[13,-10,30]], false)),

=== Revolve
Revolves Edges, Wires, and Faces about the specified Axis

    Rotate([1,0,0], 90, Revolve(Translate([10*t,8*t,0], GetWire(face)), -60, [0, 1, 0])),


=== Loft(wires, keepWires)
Interpolates along an array of wires into a continuous solid shape

    Loft([GetWire(face), Translate([0,0,20], Circle(8, true))]),



== Changing three dimensional shapes

=== Transform(translation, rotation, scale, shapes)


=== Translate(offset, shapes, keepOriginal)


=== Rotate(axis, degrees, shapes, keepOriginal)

=== Scale(scale, shapes, keepOriginal)


=== Offset(shape, offsetDistance, tolerance, keepShape)
Dilates or contracts a shape by the specified distance. This is similar to the socalled minkowski sum with a sphere (known from the OpenSCAD application) which rolls a sphere around the base shape. Note that this can be used to create a rounded cube/box from a normal cube/box.

    Offset(Text3D("H", 36, 0.15, "Roboto"), 2.25*t)
    

=== FilletEdges(shape, radius, edgeList, keepOriginal?)
Round-off an array of edges on a shape (derived from mouse hovering). Note that it is sufficient to list one of the edges in a loop or chain of edges for filleting. The behaviour is not always predictable. It seems that if there are multiple loops of which an edge can be a member, only this single edge is filleted. If there is already another fillet, it seems easier to select just a single edge to fillet a complete loop. Just try an edge and determine the result. Note that you always have to revert back to the original shape if you want to add another edge to the list, as the edge numbering is adapted after the filleting operation. 

    FilletEdges (Cylinder(10, 20), 4*t, [0,2])
    
    
    

=== ChamferEdges(shape, distance, edgeList, keepOriginal?)
Apply a 45-degree cut to an array of edges on a shape
    
    ChamferEdges(Cylinder(10, 20), 4*t, [0,2])
    
=== Difference, Union, Intersection
CSG boolean  a set of shapes from a target shape
    
    Translate([0,0,10], Difference(Sphere(10), [Cylinder(5*t, 30, true)]))


=== Union(objectsToJoin, keepObjects, fuzzValue, keepEdges)


=== Difference(mainBody, objectsToSubtract, keepObjects, fuzzValue, keepEdges)



=== Intersection(objectsToIntersect, keepObjects, fuzzValue, keepEdges)



=== RemoveInternalEdges(shape, keepShape)

// Line up the above shapes into a grid pattern for easy display
let shapeInd = 0;
for(let y = -80; y < 80; y += 40){
    for(let x = -80; x < 80; x += 40){
        if(shapeInd < shapes.length){
            Translate([x, y, 0], shapes[shapeInd]);
        }
        shapeInd++;
    }
}

== Create new functions
New functions can be declared according to the Javascript syntax. This starts with the keyword "function", then a function name (often with a capital first character) and then two rounded brackets around a list of parameters. The function performs some action using the parameters as input and can return values, wires, shapes et cetera. In the example below the function Sphere requires a definition of the radius and returns the shape of a sphere around the point [0,0,0].  

----
 function Sphere(radius) {
   let curSphere = CacheOp(arguments, () => {
    // Construct a Sphere Primitive
     let spherePlane = new oc.gp_Ax2(new oc.gp_Pnt(0, 0, 0), oc.gp.prototype.DZ());
     return new oc.BRepPrimAPI_MakeSphere(spherePlane, radius).Shape();
   });

   sceneShapes.push(curSphere);
   return curSphere;
  }
---- 

== Interface items

=== Slider(name = "Val", defaultValue = 0.5, min = 0.0, max = 1.0, realTime=false, step, precision)
Creates a simple slider that can be used to adjust parameters of the model

 let t = Slider("Param", 1, 0.4, 1.75);

=== Checkbox(name = "Toggle", defaultValue = false)


 if (Checkbox("Loft?", true)){ Loft([face1, face2, face3], true); }

Button(name = "Action")


=== SaveFile(filename, fileURL)



== Modifying CascadeStudio
As the code of CascadeStudio is available, it is possible to change items to your personal preferences. In this section some options for changes to the interface will be highlighted. 

=== Modifying the panel lay-out
When the program is started, the editor window is on the left, the 3D view on the right and the console log in the bottom of the 3D view. It is possible to adjust the position of the dividers between the panels but also to grab the tab of each panel and drag it to a completely different position. It is even possible to drag tabs into the same panel, for example to hide the console log behind the editor. 


=== Modifying the 3D view



== Shortcut keys
=== General

kbd:[F5]	Recalculate/Render


=== Editor


kbd: [F1]		Open command palette
kbd: [F12]		Go to definition
kbd: [CMD] + kbd:[F]	Find
kbd: [CMD] + kbd:[E]	Find selected text 
kbd: [ENTER]		Find next
kbd: [ALT] + kbd:[UP] 	Move line up
kbd: [ALT] + kbd:[DN] 	Move line down
kbd: [CTRL] + kbd:[Space] Trigger suggestion/info

kbd: [CMD] + kbd:[']']  Indent
kbd: [CMD] + kbd:['[']  Outdent
kbd: [ALT] + kbd:[DN] 	Move line down
kbd: [ALT] + kbd:[DN] 	Move line down

kbd: [CMD] + kbd:[/]	Toggle comment line 
kbd: [SHIFT] + kbd:[ALT] + kbd:[A] Toggle block comment
kbd:[SHIFT] + kbd:[ALT] + kbd:[UP] Copy line up
kbd:[SHIFT] + kbd:[ALT] + kbd:[DN] Copy line down

== Comparison to similar tools



== A short introduction to Javascript


The following math operations are supported:

Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **

precedence standard

Modify-in-place
We often need to apply an operator to a variable and store the new result in that same variable.

For example:

let n = 2;
n = n + 5;
n = n * 2;
This notation can be shortened using the operators += and *=:

let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)

alert( n ); // 14

Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.
Not equals. In maths the notation is ≠, but in JavaScript it’s written as a != b.



if (condition) {   } else {  } 

for (let i=0 ; i<=n ; i++){   }


=== equality without type conversion
== equal
> < => <=
|| OR
&& AND
! NOT (result = !value)








	
